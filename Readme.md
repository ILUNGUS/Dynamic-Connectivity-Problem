# Dynamic Connectivity Problem

## Введение
В вычислительной технике и теории графов структура динамической связности — это структура данных, которая динамически поддерживает информацию о связных компонентах графа.

В этой работе речь пойдет о задачах поиска компонент связности и компонент реберной двусвязности в динамически меняющихся неориентированных графах. Графом *G* называется {*V,E*}, где *V* – множество вершин графа, *E ⊂ V × V*– множество ребер графа. *|V|* обозначим за n, *|E|* обозначим за n. В начале В ходе решения задачи требуется обработать m запросов трёх типов:

- Добавить ребро между вершинами *u* и *v*
- Удалить ребро между вершинами *u* и *v*
- Проверить, лежат ли вершины u и v в одной компоненте связности.

В графе могут быть кратные ребра и петли.

В данном случае мы рассматриваем решение задачи в ***offline***, то есть ответы на все вопросы будут получены после обработки всех запросов, а не по мере их поступления

После каждого добавления/удаления ребра динамическая структура связности должна адаптироваться так, чтобы она могла давать быстрые ответы на вопросы вида «есть ли путь между x и y ?» (эквивалентно: «принадлежат ли вершины x и y одной и той же компоненте связности?»).

Если ребра могут быть только добавлены, то проблема динамической связности может быть решена с помощью структуры данных с непересекающимся набором. Каждый набор представляет связанный компонент; существует путь между x и y тогда и только тогда, когда они принадлежат к одному и тому же набору. Амортизированное время на операцию равно, где n - количество вершин, а α - обратная функция Аккермана

Для решения данной задачи воспользуемся деревом отрезком и системой непересекающихся множеств.

### Деревья отрезков
Дерево отрезков — это структура данных, которая позволяет за асимптотику ***O(logn)*** реализовать любые операции, определяемые на множестве, на котором данная операция ассоциативна, и существует нейтральный элемент относительно этой операции, то есть на моноиде. Например, суммирование на множестве натуральных чисел, поиск минимума на любом числовом множестве, перемножение матриц на множестве матриц размера N∗N, объединение множеств, поиск наибольшего общего делителя на множестве целых чисел и многочленов.

При этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива, например разрешается присвоить всем элементам a[l…r] какое-либо значение, либо прибавить ко всем элементам массива какое-либо число. Структура занимает ***O(n)*** памяти, а ее построение требует ***O(n)*** времени.

Структура представляет собой дерево, листьями которого являются элементы исходного массива. Другие вершины этого дерева имеют по 2 ребенка и содержат результат операции от своих детей (например, минимум или сумму). Таким образом, корень содержит результат искомой функции от всего массива [0…n−1], левый ребёнок корня содержит результат функции на [0…$\frac{n}{2}$], а правый, соответственно результат на [$\frac{n}{2}$+1…n−1]. И так далее, продвигаясь вглубь дерева.

### Система непересекающихся множеств

Система непересекающихся множеств — структура данных, которая позволяет администрировать множество элементов, разбитое на непересекающиеся подмножества. При этом каждому подмножеству назначается его представитель — элемент этого подмножества.

Применяется для хранения компонент связности в графах.

Каждое множество хранится в виде дерева. Элементы множества хранятся в вершинах дерева. У каждого множества есть его представитель — один из элементов этого множества, он хранится в корне дерева. В каждом узле, кроме корня, хранится ссылка на "родителя".

При объединении двух множеств, корень одного дерева подвешивается к другому (операция union). Таким образом, чтобы определить, в каком множестве находится элемент достаточно пройтись по ссылкам по дереву вверх до корня (операция get).

Без использования дополнительных "улучшений", такое дерево может выродиться в линейный список, где get будет работать за линейное время, и никакого выигрыша по сравнению с наивными реализациями не будет. Выигрыш в скорости можно получить, используя две эвристики: объединение по рангу (union by rank) и сжатие пути (path compression).

#### Объединение по рангу

Эта эвристика аналогична весовой эвристике у связных списков. Идея в том, чтобы при объединении подвешивать дерево с меньшей глубиной к дереву с большей.

Вместо того, чтобы явно хранить высоту дерева, можно хранить его ранг, который по сути является некой верхней оценкой высоты дерева. У дерева, состоящего ровно из одного элемента ранг равен 0. При объединении дерево с меньшим рангом подвешивается к дереву с большим, и ранг объединенного дерева становится равным большему из этих двух рангов. Если ранги объединяемых деревьев равны, то не важно какое к какому дереву подвешивать, но ранг объединенного дерева следует делать большим на 1.

#### Сжатие пути

Эта эвристика несколько модифицирует операцию get. Операция get вызывается для элемента x, проходит через несколько вершин и попадает в корень. Все пройденные в этом процессе вершины принадлежат тому же множеству, что и x. Поэтому мы можем подвесить (изменить ссылки) эти вершины напрямую к корню дерева и, таким образом, уменьшить его высоту. При нерекурсивной реализации операция get становится двухпроходной.

## Алгоритм

### Построение дерева отрезков
Рассмотрим массив запросов. Каждое ребро в графе существует на некотором отрезке запросов: начиная с запроса добавления и заканчивая запросом удаления (либо концом запросов, если ребро не было удалено). Для каждого ребра можно найти этот отрезок, пройдя по массиву запросов и запоминая, когда какое ребро было добавлено.

Пусть есть *k* рёбер, *i*-е соединяет вершины $v_i$ и $u_i$, было добавлено запросом $L_i$ и удалено запросом $R_i$.

Построим на массиве запросов дерево отрезков, в каждой его вершине будем хранить список пар. *i*-е рёбро графа нужно добавить на отрезок [$L_i$,$R_i$]. Это делается аналогично тому, как в дереве отрезков происходит добавление на отрезке но без push: нужно спуститься по дереву от корня и записать пару $u_i$,$v_i$ в вершины дерева отрезков.

Теперь чтобы узнать, какие рёбра существуют во время выполнения *i*-го запроса, достаточно посмотреть на путь от корня дерева отрезков до листа, который соответствует этому запросу — рёбра, записанные в вершинах этого пути, существуют во время выполнения запроса.

### Ответы на запросы
Обойдём дерево отрезков в глубину, начиная с корня. Будем поддерживать граф, состоящий из рёбер, которые содержатся на пути от текущей вершины дерева отрезков до корня. При входе в вершину добавим в граф рёбра, записанные в этой вершине. При выходе из вершины нужно откатить граф к состоянию, которое было при входе. Когда мы добираемся до листа, в граф уже добавлены все рёбра, которые существуют во время выполнения соответствующего запроса, и только они. Поэтому если этот лист соответствует запросу третьего типа, его следует выполнить и сохранить ответ.

Для поддержания такого графа и ответа на запросы будем использовать систему непересекающихся множеств. При добавлении рёбер в граф объединим соответствующие множества в СНМ. Откатывание состояния СНМ описано ниже.

### СНМ с откатами
Следующий инструмент, который нам потребуется – структуры данных с возможностью отката к предыдущим версиям.

На самом деле  любую структуру данных можно научить откатывать состояние к предыдущим версиям. Для этого достаточно хранить стек пар (указатель, значение) – адреса изменяемых ячеек памяти и старые значения этих ячеек. Теперь каждую операцию присваивания нужно обернуть в специальную функцию, которая перед изменением памяти кладет нужную информацию в стек.

Откатиться к предыдущей версии = снять со стека несколько последних операций и выполнить их в обратном порядке.

Запомнить версию ( чтобы в будущем можно было к ней откатываться) – запомнить указатель на вершину стека.

Откат – операция необратимая, если у нас были версии $V_1$, $V_2$,…, $V_9$ и мы обратимся к версии $V_2$ все версии кроме $V_1$ и $V_2$ будут навсегда забыты.


Нужно заметить, что эвристику сжатия путей в этом случае применять не следует. Эта эвристика улучшает асимптотическое время работы, но это время работы не истинное, а амортизированное. Из-за наличия откатов к предыдущим состояниям эта эвристика не даст выигрыша. СНМ с ранговой эвристикой же работает за O(logn) на запрос истинно.


Вместо описанного способа откатывания состояния СНМ можно использовать персистентный СНМ, но этот вариант сложнее и имеет меньшую эффективность.

### Формат входных данных

Поступают update-запросы двух видов- ***“ADD a b”***, ***“DEL a b”***. Гарантируется, что к моменту, когда поступает запрос ***“DEL a b”*****, ребро в графе присутствует. 

Нужно после каждого *update- запроса* знать текущее количество компонент связности и уметь отвечать на запрос *get-запрос*
***“GET a b”*** – лежат ли вершины **a b** в одной компоненте связности.


## Список литературы
1. Frederickson, Greg N., Data Structures for On-Line Updating of Minimum Spanning Trees, with Applications. CSTech-Report.No 83-449.
May 1, 1984. Paper 368.
2. Eppstein, D., Offline Algorithms for Dynamic Minimum Spanning Tree
Problems. Tech-Report.No 92-04. January 10, 1992. Dept. of Information and Computer Science,Univ. of California, Irvine, CA 92717
3. Асанов М.О., Баранский В.А., Расин В.В., Дискретная Математика: Графы, Матроиды, Алгоритмы, Ижевск: НИЦ "РХД2001", 28 стр.
1.  Кормен, Лейзерсон, Ривест, Штейн. Алгоритмы. Построение   анализ. Издание 2-е, М.: Вильямс, 2007.
1. Henzinger, M., King, V., Randomized dynamic graph algorithm with
polylogarithmic time per operation, 1995
1. Mark de Berg, Mark van Kreveld. Computational Geometry Algorithms
and Applications. Springer - Verlag Berlin Heidelberg New York, 1998
1. M. A. Bender and M. Farach-Colton. "The LCA Problem Revisited."LATIN, pages 88-94, 2000
1.	https://ru.algorithmica.org/cs/spanning-trees/dcp/
2.	https://en.wikipedia.org/wiki/Dynamic_connectivity
3.	https://habr.com/ru/company/JetBrains-education/blog/276563/
5.	https://codeforces.com/blog/entry/15296?locale=ru
1. https://neerc.ifmo.ru/wiki/index.php?title=Дерево_отрезков._Построение
1.  https://neerc.ifmo.ru/wiki/index.php?title=СНМ_(реализация_с_помощью_леса_корневых_деревьев)

